"use strict";(self.webpackChunkjsapi_angular_cli=self.webpackChunkjsapi_angular_cli||[]).push([[285],{93530:(U,I,Y)=>{function b(){return[1,0,0,0,1,0,0,0,1]}function A(M,r,c,m,d,P,s,u,l){return[M,r,c,m,d,P,s,u,l]}function j(M,r){return new Float64Array(M,r,9)}Y.d(I,{a:()=>b,c:()=>j,f:()=>A}),Object.freeze(Object.defineProperty({__proto__:null,clone:function E(M){return[M[0],M[1],M[2],M[3],M[4],M[5],M[6],M[7],M[8]]},create:b,createView:j,fromValues:A},Symbol.toStringTag,{value:"Module"}))},89568:(U,I,Y)=>{function b(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function E(r){return[r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11],r[12],r[13],r[14],r[15]]}function j(r,c){return new Float64Array(r,c,16)}Y.d(I,{I:()=>S,a:()=>b,b:()=>E,c:()=>j});const S=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];Object.freeze(Object.defineProperty({__proto__:null,IDENTITY:S,clone:E,create:b,createView:j,fromValues:function A(r,c,m,d,P,s,u,l,p,v,B,X,x,y,O,D){return[r,c,m,d,P,s,u,l,p,v,B,X,x,y,O,D]}},Symbol.toStringTag,{value:"Module"}))},7577:(U,I,Y)=>{function b(){return[0,0,0,1]}function E(r){return[r[0],r[1],r[2],r[3]]}function j(r,c){return new Float64Array(r,c,4)}Y.d(I,{I:()=>S,a:()=>b,b:()=>E,c:()=>j});const S=[0,0,0,1];Object.freeze(Object.defineProperty({__proto__:null,IDENTITY:S,clone:E,create:b,createView:j,fromValues:function A(r,c,m,d){return[r,c,m,d]}},Symbol.toStringTag,{value:"Module"}))},43548:(U,I,Y)=>{Y.d(I,{a:()=>S,b:()=>j,c:()=>E,d:()=>c,e:()=>M,n:()=>m,s:()=>r,t:()=>A});var b=Y(58466);function E(s,u,l){A(s.typedBuffer,u.typedBuffer,l,s.typedBufferStride,u.typedBufferStride)}function A(s,u,l,p=3,v=p){if(s.length/p!==Math.ceil(u.length/v))return b.c.error("source and destination buffers need to have the same number of elements"),s;const B=s.length/p,X=l[0],x=l[1],y=l[2],O=l[4],D=l[5],R=l[6],C=l[8],a=l[9],t=l[10],e=l[12],n=l[13],i=l[14];let o=0,h=0;for(let _=0;_<B;_++){const f=u[o],w=u[o+1],g=u[o+2];s[h]=X*f+O*w+C*g+e,s[h+1]=x*f+D*w+a*g+n,s[h+2]=y*f+R*w+t*g+i,o+=v,h+=p}return s}function j(s,u,l){S(s.typedBuffer,u.typedBuffer,l,s.typedBufferStride,u.typedBufferStride)}function S(s,u,l,p=3,v=p){if(s.length/p!==Math.ceil(u.length/v))return void b.c.error("source and destination buffers need to have the same number of elements");const B=s.length/p,X=l[0],x=l[1],y=l[2],O=l[3],D=l[4],R=l[5],C=l[6],a=l[7],t=l[8];let e=0,n=0;for(let i=0;i<B;i++){const o=u[e],h=u[e+1],_=u[e+2];s[n]=X*o+O*h+C*_,s[n+1]=x*o+D*h+a*_,s[n+2]=y*o+R*h+t*_,e+=v,n+=p}}function M(s,u,l){r(s.typedBuffer,u,l,s.typedBufferStride)}function r(s,u,l,p=3){const v=Math.min(s.length/p,u.count),B=u.typedBuffer,X=u.typedBufferStride;let x=0,y=0;for(let O=0;O<v;O++)s[y]=l*B[x],s[y+1]=l*B[x+1],s[y+2]=l*B[x+2],x+=X,y+=p}function c(s,u){m(s.typedBuffer,u.typedBuffer,s.typedBufferStride,u.typedBufferStride)}function m(s,u,l=3,p=l){const v=Math.min(s.length/l,u.length/p);let B=0,X=0;for(let x=0;x<v;x++){const y=u[B],O=u[B+1],D=u[B+2],R=y*y+O*O+D*D;if(R>0){const C=1/Math.sqrt(R);s[X]=C*y,s[X+1]=C*O,s[X+2]=C*D}B+=p,X+=l}}Object.freeze(Object.defineProperty({__proto__:null,normalize:m,normalizeView:c,scale:r,scaleView:M,shiftRight:function d(s,u,l){const p=Math.min(s.count,u.count),v=s.typedBuffer,B=s.typedBufferStride,X=u.typedBuffer,x=u.typedBufferStride;let y=0,O=0;for(let D=0;D<p;D++)v[O]=X[y]>>l,v[O+1]=X[y+1]>>l,v[O+2]=X[y+2]>>l,y+=x,O+=B},transformMat3:S,transformMat3View:j,transformMat4:A,transformMat4View:E},Symbol.toStringTag,{value:"Module"}))},26540:(U,I,Y)=>{Y.d(I,{Q:()=>j});var b=Y(57678),E=Y(43029),A=Y(4758);class j{constructor(t=9,e){this._compareMinX=c,this._compareMinY=m,this._toBBox=n=>n,this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),e&&("function"==typeof e?this._toBBox=e:this._initFormat(e)),this.clear()}destroy(){this.clear(),B.prune(),X.prune(),x.prune(),y.prune()}all(t){this._all(this._data,t)}search(t,e){let n=this._data;const i=this._toBBox;if(p(t,n))for(B.clear();n;){for(let o=0,h=n.children.length;o<h;o++){const _=n.children[o],f=n.leaf?i(_):_;p(t,f)&&(n.leaf?e(_):l(t,f)?this._all(_,e):B.push(_))}n=B.pop()}}collides(t){let e=this._data;const n=this._toBBox;if(!p(t,e))return!1;for(B.clear();e;){for(let i=0,o=e.children.length;i<o;i++){const h=e.children[i],_=e.leaf?n(h):h;if(p(t,_)){if(e.leaf||l(t,_))return!0;B.push(h)}}e=B.pop()}return!1}load(t){if(!t.length)return this;if(t.length<this._minEntries){for(let n=0,i=t.length;n<i;n++)this.insert(t[n]);return this}let e=this._build(t.slice(0,t.length),0,t.length-1,0);if(this._data.children.length)if(this._data.height===e.height)this._splitRoot(this._data,e);else{if(this._data.height<e.height){const n=this._data;this._data=e,e=n}this._insert(e,this._data.height-e.height-1,!0)}else this._data=e;return this}insert(t){return t&&this._insert(t,this._data.height-1),this}clear(){return this._data=new R([]),this}remove(t){if(!t)return this;let e,n=this._data,i=null,o=0,h=!1;const _=this._toBBox(t);for(x.clear(),y.clear();n||x.length>0;){if(n||(n=x.pop(),i=x.data[x.length-1],o=y.pop()??0,h=!0),n.leaf&&(e=(0,b.cq)(n.children,t,n.children.length,n.indexHint),-1!==e))return n.children.splice(e,1),x.push(n),this._condense(x),this;h||n.leaf||!l(n,_)?i?(o++,n=i.children[o],h=!1):n=null:(x.push(n),y.push(o),o=0,i=n,n=n.children[0])}return this}toJSON(){return this._data}fromJSON(t){return this._data=t,this}_all(t,e){let n=t;for(X.clear();n;){if(!0===n.leaf)for(const i of n.children)e(i);else X.pushArray(n.children);n=X.pop()??null}}_build(t,e,n,i){const o=n-e+1;let h=this._maxEntries;if(o<=h){const g=new R(t.slice(e,n+1));return S(g,this._toBBox),g}i||(i=Math.ceil(Math.log(o)/Math.log(h)),h=Math.ceil(o/h**(i-1)));const _=new C([]);_.height=i;const f=Math.ceil(o/h),w=f*Math.ceil(Math.sqrt(h));v(t,e,n,w,this._compareMinX);for(let g=e;g<=n;g+=w){const T=Math.min(g+w-1,n);v(t,g,T,f,this._compareMinY);for(let L=g;L<=T;L+=f){const k=Math.min(L+f-1,T);_.children.push(this._build(t,L,k,i-1))}}return S(_,this._toBBox),_}_chooseSubtree(t,e,n,i){for(;i.push(e),!0!==e.leaf&&i.length-1!==n;){let o,h=1/0,_=1/0;for(let f=0,w=e.children.length;f<w;f++){const g=e.children[f],T=d(g),L=s(t,g)-T;L<_?(_=L,h=T<h?T:h,o=g):L===_&&T<h&&(h=T,o=g)}e=o||e.children[0]}return e}_insert(t,e,n){const o=n?t:(0,this._toBBox)(t);x.clear();const h=this._chooseSubtree(o,this._data,e,x);for(h.children.push(t),r(h,o);e>=0&&x.data[e].children.length>this._maxEntries;)this._split(x,e),e--;this._adjustParentBBoxes(o,x,e)}_split(t,e){const n=t.data[e],i=n.children.length,o=this._minEntries;this._chooseSplitAxis(n,o,i);const h=this._chooseSplitIndex(n,o,i);if(!h)return void console.log("  Error: assertion failed at PooledRBush._split: no valid split index");const _=n.children.splice(h,n.children.length-h),f=n.leaf?new R(_):new C(_);f.height=n.height,S(n,this._toBBox),S(f,this._toBBox),e?t.data[e-1].children.push(f):this._splitRoot(n,f)}_splitRoot(t,e){this._data=new C([t,e]),this._data.height=t.height+1,S(this._data,this._toBBox)}_chooseSplitIndex(t,e,n){let i,o,h;i=o=1/0;for(let _=e;_<=n-e;_++){const f=M(t,0,_,this._toBBox),w=M(t,_,n,this._toBBox),g=u(f,w),T=d(f)+d(w);g<i?(i=g,h=_,o=T<o?T:o):g===i&&T<o&&(o=T,h=_)}return h}_chooseSplitAxis(t,e,n){const i=t.leaf?this._compareMinX:c,o=t.leaf?this._compareMinY:m;this._allDistMargin(t,e,n,i)<this._allDistMargin(t,e,n,o)&&t.children.sort(i)}_allDistMargin(t,e,n,i){t.children.sort(i);const o=this._toBBox,h=M(t,0,e,o),_=M(t,n-e,n,o);let f=P(h)+P(_);for(let w=e;w<n-e;w++){const g=t.children[w];r(h,t.leaf?o(g):g),f+=P(h)}for(let w=n-e-1;w>=e;w--){const g=t.children[w];r(_,t.leaf?o(g):g),f+=P(_)}return f}_adjustParentBBoxes(t,e,n){for(let i=n;i>=0;i--)r(e.data[i],t)}_condense(t){for(let e=t.length-1;e>=0;e--){const n=t.data[e];if(0===n.children.length)if(e>0){const i=t.data[e-1],o=i.children;o.splice((0,b.cq)(o,n,o.length,i.indexHint),1)}else this.clear();else S(n,this._toBBox)}}_initFormat(t){const e=["return a"," - b",";"];this._compareMinX=new Function("a","b",e.join(t[0])),this._compareMinY=new Function("a","b",e.join(t[1])),this._toBBox=new Function("a","return {minX: a"+t[0]+", minY: a"+t[1]+", maxX: a"+t[2]+", maxY: a"+t[3]+"};")}}function S(a,t){M(a,0,a.children.length,t,a)}function M(a,t,e,n,i){i||(i=new R([])),i.minX=1/0,i.minY=1/0,i.maxX=-1/0,i.maxY=-1/0;for(let o,h=t;h<e;h++)o=a.children[h],r(i,a.leaf?n(o):o);return i}function r(a,t){a.minX=Math.min(a.minX,t.minX),a.minY=Math.min(a.minY,t.minY),a.maxX=Math.max(a.maxX,t.maxX),a.maxY=Math.max(a.maxY,t.maxY)}function c(a,t){return a.minX-t.minX}function m(a,t){return a.minY-t.minY}function d(a){return(a.maxX-a.minX)*(a.maxY-a.minY)}function P(a){return a.maxX-a.minX+(a.maxY-a.minY)}function s(a,t){return(Math.max(t.maxX,a.maxX)-Math.min(t.minX,a.minX))*(Math.max(t.maxY,a.maxY)-Math.min(t.minY,a.minY))}function u(a,t){const e=Math.max(a.minX,t.minX),n=Math.max(a.minY,t.minY),i=Math.min(a.maxX,t.maxX),o=Math.min(a.maxY,t.maxY);return Math.max(0,i-e)*Math.max(0,o-n)}function l(a,t){return a.minX<=t.minX&&a.minY<=t.minY&&t.maxX<=a.maxX&&t.maxY<=a.maxY}function p(a,t){return t.minX<=a.maxX&&t.minY<=a.maxY&&t.maxX>=a.minX&&t.maxY>=a.minY}function v(a,t,e,n,i){const o=[t,e];for(;o.length;){const h=o.pop(),_=o.pop();if(h-_<=n)continue;const f=_+Math.ceil((h-_)/n/2)*n;(0,A.q)(a,f,_,h,i),o.push(_,f,f,h)}}const B=new E.Z,X=new E.Z,x=new E.Z,y=new E.Z({deallocator:void 0});class O{constructor(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0}}class D extends O{constructor(){super(...arguments),this.height=1,this.indexHint=new b.SO}}class R extends D{constructor(t){super(),this.children=t,this.leaf=!0}}class C extends D{constructor(t){super(),this.children=t,this.leaf=!1}}},58466:(U,I,Y)=>{Y.d(I,{c:()=>E});const E=Y(4703).Z.getLogger("esri.views.3d.support.buffer.math")},63517:(U,I,Y)=>{Y.r(I),Y.d(I,{default:()=>S});var b=Y(15861),E=Y(14007),A=Y(26540),j=Y(92859);class S{createIndex(c,m){var d=this;return(0,b.Z)(function*(){const P=new Array;if(!c.vertexAttributes?.position)return new A.Q;const s=d._createMeshData(c),u=null!=m?yield m.invoke("createIndexThread",s,{transferList:P}):d.createIndexThread(s).result;return d._createPooledRBush().fromJSON(u)})()}createIndexThread(c){const m=new Float64Array(c.position),d=this._createPooledRBush();return c.components?this._createIndexComponentsThread(d,m,c.components.map(P=>new Uint32Array(P))):this._createIndexAllThread(d,m)}_createIndexAllThread(c,m){const d=new Array(m.length/9);let P=0;for(let s=0;s<m.length;s+=9)d[P++]=M(m,s,s+3,s+6);return c.load(d),{result:c.toJSON()}}_createIndexComponentsThread(c,m,d){let P=0;for(const l of d)P+=l.length/3;const s=new Array(P);let u=0;for(const l of d)for(let p=0;p<l.length;p+=3)s[u++]=M(m,3*l[p],3*l[p+1],3*l[p+2]);return c.load(s),{result:c.toJSON()}}_createMeshData(c){const m=(c.vertexSpace.isRelative?(0,j.georeferenceApplyTransform)({position:c.vertexAttributes.position,normal:null,tangent:null},c.vertexSpace,c.transform,c.spatialReference).position:c.vertexAttributes.position).buffer;return!c.components||c.components.some(d=>!d.faces)?{position:m}:{position:m,components:c.components.map(d=>d.faces)}}_createPooledRBush(){return new A.Q(9,(0,E.Z)("esri-csp-restrictions")?c=>c:[".minX",".minY",".maxX",".maxY"])}}function M(r,c,m,d){return{minX:Math.min(r[c],r[m],r[d]),maxX:Math.max(r[c],r[m],r[d]),minY:Math.min(r[c+1],r[m+1],r[d+1]),maxY:Math.max(r[c+1],r[m+1],r[d+1]),p0:[r[c],r[c+1],r[c+2]],p1:[r[m],r[m+1],r[m+2]],p2:[r[d],r[d+1],r[d+2]]}}}}]);